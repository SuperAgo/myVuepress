---
title: 第四章 关系数据库标准语言SQL
tags:
  - 高级数据库技术
categories:
  - 复习
date: 2020-08-11 09:41:00
---
## SQL概述
SQL（Structured Query Language）是结构化查询语言的简称。然而，SQL是一种完整的数据库语言，它的功能涵盖数据定义、数据操纵（包括查询和更新）和数据控制

### SQL发展历程
SQL语言最早称为Sequel，是Boyce和Chamberlin在1974年提出的。1975-1979年IBM公司的San Jose研究实验室(现为Almaden研究中心)研制的关系数据库管理系统原型系统System R实现了这种语言。此后Sequel不断发展，并更名为SQL

SQL标准的进展过程化：  

标准|页数|发布日期
:-|:-|:-|
SQL/86|&nbsp;|1986年
SQL/89|120页|1989年
SQL/92|622页|1992年
SQL 99(SQL 3)|1700页|1998年
SQL 2003|3600页|2003年
SQL 2008|3777页|2008年
SQL 2011|&nbsp;|2011年

### SQL功能
- SQL的数据定义语言(DDL)提供了模式定义、修改和删除，基本表定义、修改和删除、域定义修改和删除、定义视图
- SQL的数据操纵语言(DML)提供了数据查询子语言
- DML还提供数据更新(数据插人、删除和修改)语句，允许用户更新数据
- SQL DML允许用户对视图进行查询和受限的更新操作
- SQL的数据控制语言（DCL）定义用户对数据对象的访问权限和审计

### SQL的特点
- 集多种数据库语言于一体
- 高度非过程化
- 面向集合的操作方式
- 一种语法两种使用方式
- 功能强大，语言简洁

集多种数据库语言于一体  
- SQL语言集数据定义语言(DDL)，数据操纵语言(DML)，数据控制语言(DCL)功能于一体
- 可以独立完成数据库生命周期中的全部活动
- 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行
- 数据操作符统一，查找、插入、刪除、更新等只需一种操作符

高度非过程化  
- 非关系数据模型的数据模纵语言“面向过程”，必须使用类似于指针的机制，指定存取路径
- SQL只要提出“做什么”，无须了解存取路径
- 系统将考察多种执行方案，选择并运行一个最优的执行方案得到结果
  - 大大减轻了用户负担
  - 有利于提高数据的独立性

面向集合的操作方式  
- 非关系数据模型采用面向记录的操作方式，操作对象是一条记录
- SQL采用集合操作方式
  - 操作对象、查找结果可以是元组的集合
  - 一次插入、删除、更新操作的对象可以是元组的集合；

一种语法两种使用方式  
- SQL是独立的语言
  - 能够独立地用于联机交互的使用方式
- SQL又是嵌入式语言
  - SQL能够嵌入到高级语言(例如C，C++，Java）程序中，供程序员设计程序时使用

功能强大，语言简洁  
- SQL是一种完整地数据库语言，其功能涵盖数据定义、数据操纵、数据控制等数据管理的主要需求
- 但SQL语言相对比较简洁，其核心动词只有9个
  - CREATE,ALTER,DROP
  - SELECT,INSERT,DELETE,UPDATE
  - GRANT,REVOKE
- SQL语言的语法简单，与英语口语的风格类似，易学易用

## 数据定义
### 数据类型
SQL支持许多内置的数据类型，并且允许用户定义新的域（数据）类型。 SQL支持的数据类型包括：CHARACTER,CHARACTBR VARYING,BIT,BIT VARYING,INTEGER,SMALLINT,NUMERIC,DECIMAL,FLOAT,REAL,DOUBLE PRECISION,DATE,TIME,TIMESTAMP和INTERVAL
- CHAR(n)：定长字符串，长度n由用户指定。省略(n)时，长度为1,CHAR的全称是CHARACTER
- VARCHAR(n)：变长字符串，最大长度n由用户指定,VARCHAR的全称是CHARACTER VARYING
  - 定长和变长字符串的差别主要表现在前者需要固定长度的空间，而后者占用的空间在最大长度范围内是可改变的
- BIT(a)：定长二进位串，长度n由用户指定。省略(n)时，长度为1
- BIT VARYING(n)：变长二进位串，最大长度n由用户指定
- INT：整数，其值域依赖于具体实现。INT的全称是INTEGER
- SMALLINT：小整数，其值域依赖于具体实现，但小于INT的值域
- NUMERIC(p,d)：p位有效数字的定点数，其中小数点右边占d位
- DEC(p,d)：p位有效数字的定点数，其中小数点右边占d位。DEC的全称是DECIMAL
- FLOAT(n)：精度至少为n位数字的浮点数，其值域依赖于实现
- REAL：实数，精度依赖于实现
- DOUBLE PRECISION：双精度实数，精度依赖于实现，但精度比REAL高
- DATE：日期，包括年、月、日，格式为YYYY-MM-DD
- TIME：时间，包括时、分、秒，格式为HH:MM:SS。TIME(n)可以表示比秒更小的单位，秒后取n位
- TIMESTAMP：时间戳，是DATE和TIME的结合
- INTERVAL：时间间隔。SQL允许对DATE、TIME和INTERVAL类型的值进行计算
- SQL提供ETRACT(field FROM Var)，从DATE、TIME和TIMESTAMP类型变量Var从提取字段field
  - 对于DATE类型的变量，field可以是YEAR、MONTH和DAY;
  - 对于TIME类型的变量，field可以是HOUR、MINUTE和SECOND;
  - 而对于TIMESTAMP类型field可以是YEAR、MONTH、DAY、HOUR、MINUTE和SECOND

### 模式的定义和删除
#### SQL环境
- 一个关系由目录名、模式名和关系名唯一确定，例如
  - Catalog2.Supply-schema.Suppliers
  - 确定Catalog2目录下Supply-schemna模式中的Suppliers关系。如果关系在默认目录的默认模式中，则可以省略目录名和模式名前缀

- SQL环境包括
  - 零个或多个目录
  - 零个或多个用户标识符（称作授权标识符）
  - 零个或多个模块和目录中的模式描述的SQL数据
- DBMS为关系的命名提供了一个三级层次结构
  - 顶层由目录（catalog）组成
  - 每个目录中包含一些模式（schema）
  - 而SQL对象（关系、视图等）都包含在模式内
>PS: SQL环境中的目录不能重名、同一目录下的模式不能重名、统一模式下的关系不能重名

#### 模式的定义
```
CREATE SCHEMA <模式名>[<模式元素>...]
```
- 创建一个以<模式名>命名的模式，并可以在创建模式的同时为该模式创建或不创建模式元素
- <模式元素>可以是表定义,视图定义、断言定义、授权定义等
- 这种格式没有授权其他用户访问创建的模式，以后可以用授权语句授权
```
CREATE SCHEMA [<模式名> AUTHORIZATION <用户名>[<模式元素>...]
```
- 与第一种的区别在于它将创建的模式授权予<用户名>指定的用户
- 当<模式名>缺省时，用<用户名>作为模式名

#### 模式删除
- DBA和模式的拥有者可以用DROP SCHEMA删除模式。删除模式的语句格式为:
```
  DROP SCHEMA<模式名>  CASCADE | RESTRICT 
```
- 其中CASCADE和RESTRICT两者必须选择其一
  - **CASCADE**，则删除<模式名>指定模式的同时并删除该模式中的所有数据库对象（基本表、视图、断言等）
  - **RESTRICT**，则仅当<模式名>指定的模式不包含任何数据库对象时才删除指定的模式，否则拒绝删除

### 表的定义、修改和删除
#### 符号约定
- < X >表示X是需要进一步定义或说明语言成分
- [ X ]表示X可以缺省或出现一次
- { X }表示X可以出现一次
- X | Y表示或者X出现，或者Y出现，但二者不能同时出现
- SQL语言的保留字(如CREATE)不区分大小写。为醒目起见，对于SQL语句中的SQL的保留字，我们使用大写

:::tip
- SQL语句用分号结束
- 一个SQL语句可以写在一行或多行中
- 多种空白符号用于分隔不同的词
:::

#### 表的定义
```
CREATE TABLE<表名>  
(
<列名><数据类型>[DEFAULT<缺省值>][列级约束定义],
<列名><数据类型>[DEFAULT<缺省值>][列级约束定义],
...,
[<表级约束定义>,...,<表级约束定义>]
);
```
:::tip
- 可选短语"DEFAULT<缺省值>"定义列上的缺省值，<缺省值>是<类型>中的一个特定值或空值(NULL)
- 列级约束定义和该列相关的完整性约束
- 表级约束定义和一个列或者多个列同时相关的完整性约束
:::

#### 列级约束的定义
`[CONSTRAINT<约束名>]<列约束>`  
"CONSTRAINT<约束名>"为列约束命名。常用的列约束包括：
- NOT NULL：不允许该列取空值；不加NOT NULL限制时，该列可以取空值
- PRIMARY KEY：指明该列是主码，其值非空、惟一
- UNIQUE：该列上的值必须惟一。这相当于说明该列为候选码
- CHECK(<条件>)：指明该列的值必须满足的条件，其中<条件>是一个涉及该列的布尔表达式
#### 表级约束的定义
`[CONSTRAINT<约束名>]<表约束>`  常用的表约束包括：
- PRIMARY KEY(A1,...,Ak)：说明属性列A1,...,Ak构成该关系的主码
- UNIQUE(A1,...,Ak)：说明属性列A1,...,Ak上的值必须唯一，这相当于说明A1,...,Ak构成该关系的候选码
- CHECK(<条件>)：说明该表上的一个完整性约束条件
- FOREIGN KEY(A1,...,Ak)REFERENCES<外表名>(<外表主码>)[<参照触发动作>]
#### 修改基本表
```
ALTER TABLE<表名>  
[ADD[COLUMN]<列名><数据类型>[列级约束定义]]  
[ALTER[COLUMN]<列名>{SET DEFAULT<缺省值>|DROP DEFAULT}]  
[DROP[COLUMN]<列名>{CASCADE|RESTRICT}]
[ADD<表约束定义>]  
[DROP CONSTRAINT<约束名>{CASCADE|RESTRICT}]
```
#### 删除基本表
`DROP TABLE<表名>{CASCADE|RESTRICT}`
- 其中CASCADE表示及联删除，依赖于表的数据对象（最常见的是视图）也将一同被删除
- RESTRICT表示受限删除，如果基于该表定义有视图，或者有其他表引用该表（如CHECK、FOREIGN KEY等约束），或者该表有触发器、存储过程或函数等，则不能删除
### 索引的创建和删除
- 索引类似于书的目录
- 索引可以加快表之间的连接速度，加快表的排序和分组工作
- 索引属于物理存储的路径概念，而不是逻辑的概念
- 索引由DBA或表的属主负责建立和删除，其他用户不能随意建立和删除索引
- 索引油DBMS自动选择和维护。索引通常分为惟一性索引（每个索引值对应一个数据行）和非惟一性索引；也可以分为聚族索引和非聚族索引
#### 索引的定义
`CREATE[UNIQUE][CLUSTER]INDEX<索引名>ON<表名>{<列名>[<次序>],...,<列名>[<次序>])`
- <索引名>为建立的索引命名
- <表名>是要建立索引的基本表的名字
- 索引可以建在该表的一列或多列上，各列名间用逗号分隔；每个<列名>后可以用<次序>指定索引值的排列次序
- 次序可以是ASC(升序)和DESC(降序)，缺省值为ASC
:::tip
- UNIQUE表示该索引为惟一性索引，UNIQUE缺省时，创建的索引为非惟一性索引
- CLUSTER表示建立的索引是聚簇索引，缺省时为非聚簇索引
- 创建索引不仅创建索引结构，而且将索引的定义存储在数据字典中
:::

#### 索引删除、
索引—旦建立，就由系统来选择和维护，无需用户干预。但当删除一些不必要的索引时，可用下列语句来实现：  
`DROP INDEX <索引名>`  
删除索引时，系统将删除索引结构，并同时从数据字典中删去有关该索引的定义

## 数据查询
### 简单查询
- 查询是数据库的最重要的操作 
- 在SQL中，所有查询都用SELECT语句实现 
- 查询在一个或多个关系（基本表或视图）上进行，其结果 是一个关系
#### SELECT语句的一般形式
- SELECT语句的一般形式如下：  
  `SELECT [ALL︱DISTINCT] <选择序列>`
  - FROM <表引用>, …, <表引用> 
  - [WHERE <查询条件>]
  - [GROUP BY <分组列>,...,<分组列> [HAVING <分组选择条件>]] 
  - [ORDER BY <排序列> [ASC︱DESC],..., <排序列> [ASC︱DESC]}] 
- 最基本的结构是SELECT-FROM-WHERE，并且SELECT子句和 FROM子句是必须的，其他子句都是可选的

SELECT子句  
- 相当于关系代数的投影运算，用来列出查询结果表的诸列
  - SELECT后可以使用集合量词ALL或DISTINCT，缺省时为ALL
  - ALL不删除结果的重复行，而DISTINCT将删除结果中的重复行
  - ALL或DISTINCT作用于所有列而不是一个列
- <选择序列>有两种形式
  - 列举查询结果的每个列
  - *
:::tip
- 结果列的次序可以任意指定，列之间用逗号隔开。每个结果列具有如下形式  
  `<值表达式> [[AS] <列名>]`
- <值表达式>最常见形式为  
  `[<表名>.]<列名>`
- <列名>必须出现在FROM子句指定的表中
- 在不会引起混淆（即<列名>只出现在一个表中）时，<列名>前的可选前缀“<表名>.”可以缺省。<表名>是<列名>所在表的名字或别名（见FROM子句）
:::
#### 不带WHERE子句的简单查询
最简单的SELECT语句是只包括SELECT和FROM子句。这
种语句只能完成对单个表的投影运算
#### 带WHERE的查询
**复杂查询都需要使用WHERE子句说明查询条件**  
Where子句的常用形式  

表达式形式|谓词
:-|:-
比较表达式|<、<=、>、>=、=、<>或!= 
BETWEEN表达式|BETWEEN AND, NOT BETWEEN AND
IN表达式|IN, NOT IN
LIKE表达式|LIKE, NOT LIKE
NULL表达式|IS NULL, IS NOT NULL
存在表达式|EXIST, NOT EXIST
唯一表达式|UNIQUE

比较表达式  
- 比较表达式的常见形式如下：  
`<值表达式1>θ<值表达式2>`
- 其中θ是比较运算符（<、<=、>、>=、=、<>或!=），<值表达式1>和<值表达式2>都是可求值的表达式，并且它们的值可以进行比较。通常，这些值表达式是常量、属性和数。比较表达式根据比较关系是否成立产生真假值

BETWEEN表达式  
- 判定一个给定的值是否在给定的闭区间，其最常见形式是：  
`<值表达式> [NOT] BETWEEN <下界> AND <上界>`
- 其中<值表达式>、<下界>和<上界>都是可求值的表达式，其值是序数类型
- <下界>的值小于或等于<上界>
- 当且仅当<值表达式>的值在<下界>和<上界>确定的闭区间时，<值表达式> BETWEEN <下界> AND <上界>为真，而<值表达式>NOT BETWEEN <下界> AND <上界>为假

IN表达式  
- 判定一个给定的元素是否在给定的集合中  
- IN表达式有两种形式：  
`<值表达式> [NOT] IN (<值表达式列表>)`  
`<元组> | [NOT] IN <子查询>`
- 在第一种形式中，<值表达式>是可求值的表达式（通常是属性），而<值表达式列表>包括一个或多个可求值的表达式（通常是字面值，如45，‘教授’等），中间用逗号隔开
- 当且仅当<值表达式>的值出现在<值表达式列表>中, <值表达式> IN(<值表达式列表>)为真, 而<值表达式> NOT IN (<值表达式列表>)为假

LIKE表达式  
- LIKE表达式允许进行模糊查询  
- LIKE表达式的一般形式为：  
`[NOT] LIKE <匹配串> [ESCAPE ‘<换码字符>’]`  
- 其中，<匹配串>是给定的字符串常量，允许使用通配符。有两种通配符：
  - “_”（下横线）可以与任意单个字符匹配
  - “%”可以与零个或多个任意字符匹配
  - ESCAPE ‘<换码字符>’用于定义转义字符，将紧随其后的一个字符转义

NULL表达式
- SQL允许元组的某些属性上取空值（NULL）。空值代表未知的值，不能与其他值进行比较
- NULL表达式允许我们判定给定的值是否为空值。NULL表达式的常见形式如下:  
`<值表达式> | <子查询> IS [ NOT ] NULL`
- 通常，<值表达式>是属性
  - 例如, 如果A是属性,则A IS NULL 为真当且仅当属性A上取空值
### 连接查询
- 查询需要的信息和查询条件涉及的属性分布在多个表中
- SQL支持多表查询，允许FROM子句中包括多个表
- 当FROM子句中包多个表时，相当于求这些表的笛卡尔积
- 可以在WHERE子句中说明连接条件，并通过SELECT子句选取所需要的属性来实现各种连接
### 嵌套查询
- SQL是一种结构化查询语言，它允许将一个查询作为子查询嵌套在另一个SPLECT语句中
- 最常见的嵌套是将子查询嵌套在WHERE子句或HAVING短语的条件中
- 称将一个查询嵌套在另一个查询中的查询称为嵌套查询，并称前者为子查询（内层查询），后者为父渣询（外层查询)
:::tip
- 不相关子查询
  - 不相关子查询的子查询的条件不依赖于父查询
- 相关子查询
  - 相关子查询的子查询的条件依赖于父查询
:::

IN引出的子查询  
- IN表达式的第二种形式可以更一般地判定集合成员资格，其形式如下：  
`<元组>[NOT]IN<子查询>`  
- 其中<元组>形如(<值表达式>,...,<值表达式>)，并且当元组只有一个分量时，可以省略圆括号。当且仅当<元组>出现在<子查询>的结果中，<元组>IN<子查询>为真，而<元组>NOT IN<子查询>为假

集合的比较引出的子查询  
- SQL允许将一个元素与子查询的结果集进行比较。这种量化比较表达式的常用形式是：  
`<值表达式>θ ALL|SOME|ANY<子查询>`
- 其中<值表达式>通常是属性，θ是比较运算符(=、<>、!=、<、>、>=、<=)。SOME和ANY的含义相同。早期只有ANY，但容易与英语中的any一词在语言上混淆，现在更多的使用SOME。当<子查询>的结果为单个值时，ALL、SOME和ANY可以省略
:::tip
- 用聚集函数实现子查询通常比直接用SOME或ALL查询效率要高。SOME和ALL与集函数的对应关系如下表所示  

&nbsp;|=|!=或<>|<|<=|>|>=
-|-|-|-|-|-|-
SOME|IN|—|<MAX|<=MAX|>MIN|>=MIN
ALL|—|NOT IN|<MIN|<=MIN|>MAX|>=MAX
:::

存在量词引出的子查询  
- 一般形式如下  
`EXISTS<子查询>`
- 其中<子查询>的SELECT子句的形式为：SELECT *。EXISTS<子查询>为真，当且仅当<子查询>的结果非空（至少包含一个元组）

### 分组和排序
#### 查询结果分组
聚集函数辅助查询  

聚集函数名|含义
:-|:-
`COUNT([ALL|DISTINCT]*)`|统计元组个数
`COUNT([ALL|DISTINCT]列名)`|统计一列中值的个数
`SUM([ALL|DISTINCT]列名)`|统计一列值的总和
`AVG([ALL|DISTINCT]列名)`|统计一列值的平均值
`MAX([ALL|DISTINCT]列名)`|统计一列值的最大值
`MIN([ALL|DISTINCT]列名)`|统计一列值的最小值

:::tip
ALL和DISTINCT是可选的，默认为ALL；  
(1)f(ALL e)或f(e)对每个分组，首先对该分组中每个分组计算e，得到e值的多重集，然后，将f作用于该多重集得到聚集函数值；  
(2)f(DISTINCT e)在得到函数值之前要删除多重集中的重复元素
:::
#### 查询结果排序
ORDER BY子句可以将查询的结果按一定次序显示，其形式如下：  
`ORDER BY <排序列>[ASC|DESC] {,<排序列>[ASC|DESC]}`
- 其中，<排序列>是必须出现在SELECT子句中的属性名或属性的别名
- ORDER BY 后可以有一个或多个<排序列>，中间用逗号隔开
- 每个<排序列>都可以独立指定按升序（ASC）还是按降序（DESC）排序，缺省时为升序
- 如果指定多个<排序列>，则查询结果按指定的次序，首先按第一个<排序列>的值排序，第一个<排序列>值相同的结果元组按第二个<排序列>的值排序，如此下去
### 集合查询
- SQL语言也支持传统的集合运算，包括并（UNION）、交(INTERSECT）、差（EXCEPT）。集合运算的常见形式为：<元组集表达式><集合运算符>[ALL]<元组集表达式>
- 其中<元组集表达式>产生元组的集合，通常是SELECT查询或集合运算的结果
- <集合运算符>是UNION、INTERSECT或EXCEPT
- 集合运算将自动删除结果中的重复元组。可选的ALL可以用来保留运算结果中的重复元组
## 数据更新
### 插入
向基本表插入单个元祖  
`INSTER INTO T[(A<sub>1</sub>,...,A<sub>k</sub>)] VALUES((C<sub>1</sub>,...,C<sub>k</sub>))`
- 其中T通常是基本表，也可以是视图，A<sub>1</sub>,...,A<sub>k</sub>是T的属性，C<sub>1</sub>,...,C<sub>k</sub>是常量

将查询的结果(多个元祖)插入基本表  
`INSTER INTO T[(A<sub>1</sub>,...,A<sub>k</sub>)]`
### 删除
DELETE语句格式为：  
`DELETE FROM T [WHERE<删除条件>]`  
- 其中T通常是基本表，但也可以是某些视图；<删除条件>与SELECT语句中的查询条件类似
### 修改
UPDATE语句格式为：  
`UPDATE T SET A1 = e1,...,Ak = ek [	WHERE<修改条件>]`  
- 其中T通常是基本表，但也可以是某些视图；A1,...,Ak是T的属性，而e1,...,ek是表达式；<删除条件>与SELECT语句中的查询条件类似
## 视图
### 视图的作用
- 使用视图可以使一些查询表达更加简洁
- 视图提供了一定程度的逻辑独立性
- 视图可以起到安全保护作用
- 视图使得用户能够以不同角度看待相同的数据

### 定义视图和删除视图
视图定义：  
`CREATE VIEW <视图名>[(<列名>,...,<列名>)]AS<查询表达式>[WITH CHECK OPTION]`
- <视图名>对定义的视室命名。<列名>为<查询表达式>结果的诸列命名
- <查询表达式>通常是一个SELECT查询，其中不包含DISTINCT短语和ORDER BY子句
- WITH CHECK OPTION表示该视图是可更新的，并且对视图进行更新时要满足<查询表达式>的查询条件与SELECT语句中的查询条件类似

视图删除：  
`DROP VIEW <视图名>[CASCADE|RESTRICT]`  
- 删除视图就是把视图的定义从数据字典中删除。CASCADE或RESTRICT是可选的，缺省时为RESTRICT
### 基于视图的查询
- 从用户角度讲，查询时使用视图与使用基本表并无区别
- 例如 查询软件工程专业的男生`SELECT * FROM SE_Students WHERE Sex='男');`等价于`SELECT * FROM (SELECT Sno, Sname, Sex, Birthday, Dno FROM Students WHERE Speciality = '软件工程'）AS SE_Students (Sno, Sname, Sex, Birthday, Dno)WHERE Sex='男';`
### 基于视图的更新
- 视图的更新是指通过视图进行增、删、改操作
- 由于视图都是直接或间接基于基本表定义的，因此基于视图的更新最终要转换成基本表的更新
- 有些视图可以将更新唯一地转换成对定义它的基本表的更新，这种视图被称为可更新的视图；有些视图不能将更新唯一地转换成对定义它的基本表的更新，这种视图被称为不可更新视图
- 定义视图时加上WITH CHECK OPTION子句，系统在更新视图时会自动检查视图定义中的条件，不满足条件则拒绝更新
## 嵌入式SQL
### 为什么使用嵌入式SQL
- SQL是一种非过程语言，用SQL语言表达查询比用通用的程序设计语言编码简单得多
- 然而，至少有两条理由，使得我们在开发数据库应用系统时需要使用通用程序设计语言访问数据库;
  - 1.SQL能够表达常见的查询，但是不能表达所有查询
  - 2.一些非数据库操作，如打印报表、将查询结果送到图形用户界面中，都不能用SQL语句实现

## 本章测验
1【单选题】定义表的SQL语句是（  ）  
A、CREATE DATABASE  
B、CREATE TABLE  
C、CREATE VIEW  
D、CREATE INDEX  

2【单选题】定义索引的SQL语句是（  ）  
A、CREATE DATABASE  
B、CREATE TABLE  
C、CREATE VIEW  
D、CREATE INDEX  

3【单选题】修改基本表结构的SQL语句是（  ）  
A、ALTER DATABASE  
B、B.ALTER TABLE  
C、DROP TABLE  
D、DROP INDEX

4【单选题】定义主码的SQL语句是（  ）  
A、PRIMARY KEY  
B、FOREIGN KEY  
C、NOT NULL  
D、UNIQUE

5【单选题】定义外码的SQL语句是（  ）  
A、PRIMARY KEY  
B、FOREIGN KEY  
C、NOT NULL  
D、UNIQUE

6【单选题】定义候选码的SQL语句是（  ）  
A、PRIMARY KEY  
B、FOREIGN KEY  
C、NOT NULL  
D、UNIQUE

7【单选题】用于删除数据库对象的SQL语句是（  ）  
A、CREATE  
B、ALTER  
C、DROP  
D、REVOKE

8【单选题】定义聚集索引使用下面哪个关键字（  ）  
A、UNQIUE  
B、UNCLUSTER  
C、CLUSTER  
D、以上都不对

9【单选题】表达查询时，下面哪些子句是必不可少的（  ）  
A、SELECT 和FROM  
B、SELECT和 WHERE  
C、FROM和WHERE  
D、SELECT.FROM和WHERE

10【单选题】表达查询条件的子句是（  ）  
A、SELECT子句  
B、FROM子句  
C、WHERE子句  
D、ORDER BY子句

11【单选题】用于排序的是（  ）  
A、SELECT子句  
B、LIKE短语  
C、GROUP BY子句  
D、ORDER BY子句

12【单选题】用于分组的是（  ）  
A、SELECT子句  
B、LIKE短语  
C、GROUP BY子句  
D、ORDER BY子句

13【单选题】用于模糊查询的是（  ）  
A、SELECT子句  
B、LIKE短语  
C、GROUP BY子句  
D、ORDER BY子句

14【单选题】下面说法正确的是（  ）  
A、没有GROUP BY时不能使用聚集函数  
B、GROUP BY不能细化聚集函数的作用范围  
C、有分组子句的查询语句中，SELECT子句中的结果列必须是分组子句中的分组属性或者聚集函数  
D、以上都不对

15【单选题】下面哪个聚集函数是用来计数的（  ）  
A、MAX()  
B、MIN()  
C、SUM()  
D、COUNT()

16【单选题】SQL语句中实现并操作的是（  ）  
A、UNION  
B、INTERSECT  
C、EXCEPT  
D、以上都不对

17【单选题】SQL语句中实现交操作的是（  ）  
A、UNION  
B、INTERSECT  
C、EXCEPT  
D、以上都不对

18【单选题】SQL语句中实现差操作的是（  ）  
A、UNION  
B、INTERSECT  
C、EXCEPT  
D、以上都不对

19【单选题】SQL语句中实现插入操作的是（  ）  
A、UPDATE  
B、INSERT  
C、DELETE  
D、以上都不对

20【单选题】SQL语句中实现修改操作的是（  ）  
A、UPDATE  B.INSERT  C.DELETE  D.以上都不对

21【单选题】SQL语句中实现删除操作的是（  ）  
A、UPDATE  
B、INSERT  
C、DELETE  
D、以上都不对

22【单选题】关于视图下面说法正确的是（  ）  
A、视图和基本表一样，可以基于视图做各种查询和更新操作  
B、不能基于行列子集视图更新  
C、基于视图定义的视图可以被更新  
D、基于聚集函数定义的视图不能被更新

23【单选题】关于视图下面说法不正确的是（  ）  
A、使用视图可以使一些查询表达更加简洁  
B、视图提供了一定程度的物理独立性  
C、视图可以起到一定安全保护作用  
D、视图使得用户以不同角度看待相同的数据

24【单选题】定义视图的SQL语句是（  ）  
A、CREATE DATABASE  
B、CREATE TABLE  
C、CREATE VIEW  
D、CREATE INDEX

25【单选题】SQL语句和主语言之间的通信不能通过（  ）  
A、SQLCODE  
B、变量  
C、主语言变量  
D、游标

26【单选题】当查询的结果为多个元组时，必须使用什么来保存查询结果（  ）  
A、SQLCODE  
B、变量  
C、主语言变量  
D、游标

27【单选题】主语言可以通过什么向SQL语句传递参数（  ）  
A、SQLCODE  
B、变量  
C、主语言变量  
D、游标
