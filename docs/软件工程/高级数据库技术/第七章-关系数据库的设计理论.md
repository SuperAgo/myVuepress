---
title: 第七章 关系数据库的设计理论
tags:
  - 高级数据库技术
categories:
  - 复习
date: 2020-08-13 14:39:00
---
## 问题提出
### 不好的设计可能导致的问题
- 冗余
- 插入异常
- 更新异常
- 删除异常
### 数据依赖与冗余
- 数据依赖是语义概念，是关于关系诸属性值之间内在相关性的陈述，它规定了关系模式的合法关系实例所必须满足的条件
- 依赖和冗余都是密不可分的
  - 承认某种数据依赖，我们就可以发现关系中的某些冗余
  - 不承认数据之间的依赖关系，也就没有理由认为某些信息是冗余的
- 冗余的产生原因和处理也总是联系在一起的
## 函数依赖
### 函数依赖的定义
- 设R(A1,A2,...,An)是一个关系模式，X和Y是{A1,A2,...,An}的子集。如果对于R的任意可能的关系r，若t1,t2∈r t1[X]=t2[X]，则t1[Y]=t2[Y]，那么我们就称在关系模式R上函数依赖(functional dependency)X→Y成立
- X→Y读作“X函数确定Y”,或“Y函数依赖于X”
- X→Y对于关系模式R成立意味着：只要关系r是R的实例，则r中就不存在两个不同的元组，它们在属性集X的所有分量上一致，而在属性集Y的一个或多个分量上不一致
#### 符号约定
- 字母表开头的大写字母（或加下标）表示单个属性
- 字母表尾部的大写字母U,V,...,Z（或加下标）一般表示属性集，但也可能是由单个属性构成的集合。U也常常用于表示关系的全部属性组成的集合
- 串接用于表示并。这样，A<sub>1</sub>A<sub>2</sub>...A<sub>n</sub>表示集合{A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>}，而XY是X∪Y的缩记。此外，若A是单个属性，X是属性集，则XA或AX表示X∪{A}。
- R表示关系模式
- 有时也直接用属性的串接表示关系模式。例如，如果一个关系模式具有属性A，B和C，我们可以用ABC表示它
- 使用R表示关系模式R的属性的集合。例如，X⊆R表示X是R的属性子集
- r表示关系，它是关系模式R的某个实例，t,u,v（或加下标，如t<sub>i</sub>）表示元组。如果是属性集，则t[X]是元组t在属性集X上的投影，它是元组t在属性集X上的分量构成的元组在上述符号约定下函数依赖{Reader-no}→{Reader-name)可以写成Reader-no--Reader-name
### 函数依赖的意义
- 函数依赖的成立都是自然的  
- 函数依赖是语义概念，是关于关系模式R的所有可能关系的命题
- 不能仅仅考察R的一个特定关系r就断言函数依赖X→Y对于关系模式R成立
  - 例如，如果r是空集，则任何函数依赖在r上都成立，但随着关系r的值改变，它们中的大多数并不能一般成立
- 然而可以通过考察R的一个特殊的关系r来发现某个函数依赖在R上不成立
- 确定关系模式R的函数依赖的唯一办法是仔细考虑属性的含义
  - 从这种意义上讲，函数依赖是关于现实世界的断言

#### 平凡的函数依赖
- 如果函数依赖X→Y对于任何包含X和Y的关系模式R都成立，则称函数依赖X→Y是平凡的函数依赖
- 这等价于说：函数依赖X→Y是平凡的，如果Y⊆X
- 列举函数依赖时，我们可以忽略平凡的函数依赖，但是，当从给定的函数依赖推导新的函数依赖时，平凡的函数依赖是有用的
- 平凡的函数依赖的两个极端例子是
  - X→∅和∅→ ∅
### 逻辑蕴涵的依赖集的闭包
#### 逻辑蕴涵
给定R的一个函数依赖集F，可以推断某些函数依赖必然在R中成立
:::tip
设F是关系模式R的函数依赖集，X→Y是一个函数依赖。如果对于R的任意关系r，只要r满足F中的函数依赖，则r也满足X→Y，那么就称F逻辑蕴涵(logicallyimply)X→Y,记作F╞X→Y
:::
#### F的闭包
- 设F是关系模式R的函数依赖集，定义F的闭包(closure)F<sup>+</sup>为被F逻辑蕴涵的函数依赖的集合，即F<sup>+</sup>={X→Y|F╞X→Y}
- F中的任何函数依赖都在F<sup>+</sup>中。设F是关系模式R的函数依赖集。我们说函数依赖X→Y在R中成立等价于说X→Y在F<sup>+</sup>中函数依赖集的闭包具有一般闭包的性质
  - 对于任意函数依赖集F，(F<sup>+</sup>)<sup>+</sup>=F<sup>+</sup>
  - 即函数依赖集F的闭包的闭包等于函数依赖集F的闭包
#### 码的形式化定义
- 设R(A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>)是关系模式，F是R的函数依赖集，并且X是{A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>}的子集。如果(1)X→A<sub>1</sub>A<sub>2</sub>...A<sub>n</sub>在F<sup>+</sup>中，并且(2)不存在Y⊆X使得Y→A<sub>1</sub>A<sub>2</sub>...A<sub>n</sub>在F<sup>+</sup>中，则称X为R的码(key)
- 超码(super key)表示码的任意超集
  - 超码满足码的条件(1)，而不一定满足条件(2)。码是超码的特殊情况，它满足条件(2)
- 在一些文献中，码又称候选码（candidate key），而被选作区分关系元组的候选码称作主码(prime key)
## 函数依赖的推导
### Armstrong公理
Armstrong首先研究了函数依赖的推导问题，给出了一组有效、完备的推理规则，称为Armstrong公理，使得我们可以能够方便地从F推导出其他函数依赖  
Armstrong公理：  
设R(U)是关系模式，U是R的属性集，F是R上的函数依赖集，仅涉及U中的属性。 Armstrong公理包括以下三条推理规则：  
- A1.自反律(teflexivity)：如果Y⊆X⊆U，则X→Y成立
- A2.增广律(augmentation)：如果X→Y成立，并且Z⊆U，则XZ→YZ成立
- A3.传递律(transitivity)：如果X→Y和Y→Z成立，则X→Z成立

附加的推理规则  
- 合并规则：如果X→Y和X→Z成立，则X→YZ成立
- 伪传递规则：如果X→Y和WY→Z成立，则WX→Z成立
- 分解规则：如果X→Y成立，并且Z⊆Y，则X→Z成立
- 证明：
  - 用Z增广X→Y得到XZ→YZ，用x增广X→Z得到X→XZ。由已证的X→XZ和XZ→YZ，利用传递律我们得到X→YZ
  - 用W增广X→Y得到XW→WY，再由WY→Z和传递律得到XW→Z
  - 由Z⊆Y得到Y→Z，再由X→Y和传递律我们得到X→Z
- 推论7.1：在关系模式R中，X→A<sub>1</sub>A<sub>2</sub>...A<sub>m</sub>成立当且仅当对于1≤i≤m，X→A<sub>i</sub>成立
### 属性集的闭包
设F是关系模式R(U)上的函数依赖集，X⊆U。我们定义属性集X关于F的闭包X<sub>F</sub><sup>+</sup>={A|X→A可以用Armstrong公理由F导出}

相关引理：  
- 引理7.1：Armstrong公理是有效的。即如果函数依赖X→Y能够使用Armstrong公理由F推出，则F╞X→Y
- 引理7.2：函数依赖X→Y能用Armstrong公理由给定的函数依赖集F导出，当且仅当Y⊆X<sub>F</sub><sup>+</sup>
- 引理7.3：Armstrong公理是完备的。即如果F╞X→Y，则X→Y能够使用Armstrong公理由F推出
- 定理7.1：Armstrong公理是有效的、完备的。即如果X→Y能够使用Armstrong公理由F推出，当且仅当F╞X→Y
- 由定理7.1，我们可以得到F+和X<sub>F</sub><sup>+</sup>的等价定义：
  - F+={X→Y|X→Y能够使用Armstrong公理由F推出}
  - X<sub>F</sub><sup>+</sup>={A|F╞X→A}
### 函数依赖集的等价和极小覆盖
- 设F和G是函数依赖集，如果F<sup>+</sup>=G<sup>+</sup>，则称F与G等价，记作F≡G
- 若F≡G，则称F是G的一个覆盖，或G是F的一个覆盖
- 判断F是否与G等价不必计算F<sup>+</sup>和G<sup>+</sup>，下面的定理表明了这一点。
- 定理7.3：F≡G当且仅当F⊆G<sup>+</sup>，并且G⊆F<sup>+</sup>
- 因为F⊆G<sup>+</sup>当且仅当如果X→Y∈F则X→Y∈G<sup>+</sup>。而X→Y∈G<sup>+</sup>当且仅当Y⊆X<sub>G+</sub>。因此，我们有
- 推论7.2：F≡G当且仅当如果X→Y∈F产则Y⊆X<sub>G+</sub>，并且如果X→Y∈G则Y∈X<sub>F+</sub>

#### 极小函数依赖
- 我们说函数依赖集F是极小的(minimal)，如果
  - (1)F中的每个函数依赖的右部都是单个属性;
  - (2)不存在函数依赖X→A∈F和Y⊂X使得F-{X→A}∪{Y→A}与F等价；
  - (3)不存在函数依赖X→A∈F使得F与F-{X→A}等价
- 注意
  - 条件(1)要求F中的函数依赖的右部都是极小的
  - 条件(2)要求F中的函数依赖的左部都是极小的(不可约的)
  - 条件(3)保证F中不含多余的函数依赖
- 如果G是极小函数依赖集，并且G≡F，则称G为F的极小覆盖(minimal cover)
#### 正则覆盖
算法的正确性——定理7.4  
- 如果我们合并Fm中具有相同左部的函数依赖的右部，根据推论6.1，所得到的函数依赖集（记作Fc）与Fm等价（从而与F等价），我们称Fc为F的正则覆盖(canonical cover)
- 删除函数依赖左部的冗余属性时，可能会有不同的选择，因而导致不同的结果。例如，给定  
    AB→C, A→B, B→A  
    我们可以从AB→C的左部删除A或B，但不能同时删除二者
- 类似地，在删除冗余函数依赖时，以不同的次序考虑函数依赖也可能导致不同的结果。例如，给定  
    A→B, A→C, B→A. C→A, B→C  
	我们可以删除A→C和B→A，或者删除B→C，但不能同时删除它们
## 关系模式的范式
### 范式与规范化概述
- 关系模式的范式是关系模式的规范化形式的简称，我们将讨论4种形式的范式
- 1971年和1972年，Codd先后提出了1NF，2NF和3NF，讨论了关系模式的规范化问题
- 1NF (first normal form)要求**关系的所有属性值都是原子的**
- 2NF和3NF都利用函数依赖定义
  - 2NF不能解决多少实际问题
  - 3NF是一种更高级的范式，3NF能够处理函数依赖发现的大部分冗余和异常，但仍然不能完全解决问题

#### 范式
- Boyce和Codd共同提出对3NF的改进形式，被数据库界用二人名字命名，称作Boyce-Codd 范式，简称BCNF
  - 从函数依赖的角度，BCNF是最高级的范式形式。也就说，如果关系模式中仍然存在冗余，函数依赖既不能发现它们，也不能消除它们
- Fagin，Delobel和Zaniolo独立地发现了一种更高级的数据依赖形式——多值依赖
  - 多值依赖可以看作函数依赖的推广，可以用来发现和处理更多的冗余和存储异常
  - 借助于多值依赖，Fagin引进了第四范式（4NF），并且表明在同时考虑函数依赖和多值依赖时，4NP是最高级的范式形式
- 其实多值依赖也不能发现和处理冗余带来的所有的问题。这导致连接依赖和第五范式(5NF)概念的提出
- 连接依赖在实践中很少遇到，因而不如函数依赖和多值依赖重要
#### 范式的关系
- 1NF
- 2NF
- 3NF
- BCNF
- BCNF⊂3NF⊂2NF⊂1NF
- 关系模式的规范化方法有多种，其中已经形成系统的理论和算法的规范化方法是基于投影分解，基于连接恢复的方法
  - 对于这种规范化方法，关系模式规范化就是通过模式分解，将一个低级范式的关系模式分解成多个关系模式，这些关系模式是更高级的范式
#### 1NF
1NF(first normal form)要求关系的所有属性值都是原子的
- 1NF是对关系模式的基本要求，不满足1NF的数据模式不能称为关系模式
- 所有关系模式都是1NF
### 2NF、3NF和BCNF
#### 2NF
- 设R是关系模式，A是R的任意属性。如果A在R的某个码中，则称A是R的主属性（prime attribute），否则称A是R的非主属性（non-prime attribute)
  - 注意，R的任何码中的属性都是主属性，而非主属性不在任何码中出现
- 2VF（2nd Normal Form），关系模式R是2NF，对于任意的非平凡函数依赖X→A∈F<sup>+</sup>，必须满足下列两个条件之一：1）就有A是主属性,2）X不是R的任何码的真子集
  - 2NF对主属性的依赖性未加限制，而对非主属性，只要求不能依赖于码的真子集
#### 3NF
关系模式R是3NF（3rd Normal Form），对于任意的非平凡函数依
赖X→A∈F<sup>+</sup>，必须满足下列两个条件之一：1）A是主属性，2）X是R的超码
- 3NF要求非主属性函数依赖于超码，但是仍未限制主属性
- 当R的码唯一或R的多个码都是单个属性时，对于非平凡的函数依赖，主属性也必须函数地依赖于超码
- 当R具有多个码，并且至少有一个码包含多个属性时，就可能出现主属性对码的真子集的非平凡依赖
#### BCNF
- Boyce和Codd注意到不限制主属性仍然可能导致问题，提出了对3NF定义的修订版本，称作BCNF
- 设R是关系模式，F是R上的函数依赖集。关系模式R是BCNF（Boyce-Codd Nomnal Form），对于任意的非平凡函数依赖X→A∈F<sup>+</sup>，就有X是R的超码
### 函数依赖与范式
- 对于任何关系模式R，以下两种函数依赖必定成立：
  - (1)平凡的函数依赖
  - (2)任意属性对超码的依赖
- BCNF限制R中成立的所有函数依赖要么是平凡的，要么是对超码的依赖
  - BCNF中只有必须成立的函数依赖
  - 从函数依赖的角度（即仅考虑函数依赖），BCNF已经达到最高的规范化形式
## 关系模式的分解
### 无损连接分解
- 设r是关系模式R的一个任意关系。关系模式R的的分解ρ={R<sub>1</sub>,R<sub>2</sub>,...,R<sub>k</sub>}不仅将R分解成k个关系模式R<sub>1</sub>,R<sub>2</sub>,...,R<sub>k</sub>，而且也将关系r分解成k个关系r<sub>1</sub>,r<sub>2</sub>,...,r<sub>k</sub>，它们分别为在R<sub>1</sub>,R<sub>2</sub>,...,R<sub>k</sub>上的投影，记作:  
    π<sub>R<sub>1</sub></sub>(r),π<sub>R<sub>2</sub></sub>(r),...,π<sub>R<sub>k</sub></sub>(r)
- 很自然的问题是：π<sub>R<sub>1</sub></sub>(r),π<sub>R<sub>2</sub></sub>(r),...,π<sub>R<sub>k</sub></sub>(r)是否与r包含同样多的信息？
- 记m<sub>ρ</sub>(r)= π<sub>R<sub>1</sub></sub>(r)⋈π<sub>R<sub>2</sub></sub>(r)⋈...⋈π<sub>R<sub>k</sub></sub>(r)
- 引理7.4：设R是关系模式，ρ={R<sub>1</sub>,R<sub>2</sub>,...,R<sub>k</sub>}是R的一个分解，r是R的一个任意关系，则
  - (1)r⊆m<sub>ρ</sub>(r)
  - (2)如果s=m<sub>ρ</sub>(r)，则πR<sub>i</sub></sup>(s)=r<sub>i</sub>
  - (3)m<sub>ρ</sub>( m<sub>ρ</sub>(r))=m<sub>ρ</sub>(r)
- 设R是关系模式，D是R上的数据依赖集，ρ={R<sub>1</sub>,R<sub>2</sub>,...,R<sub>k</sub>}是R的一个分解。如果对于R的任意关系实例r都有r=m<sub>ρ</sub>(r)。则称ρ为R关于数据依赖集D的一个无损连接分解(lossless-join composition)
### 保持函数依赖的分解
- 设F是关系模式R上的函数依赖集，W是R的属性集。我们定义函数依赖集F在W上的投影(projection)为{X→Y|X→Y∈F<sup>+</sup>，并且XY⊆W}的一个覆盖，记作π<sub>w</sub>(F)。F在W上的投影又称F在W上的限制
- 在关系模式R的分解ρ={R<sub>1</sub>,...,R<sub>k</sub>}不仅把R分解成k个关系模式，而且也把R上的函数依獭集F分解成k个函数依赖集：π<sub>R<sub>1</sub></sub>(F),...,π<sub>R<sub>k</sub></sub>(F)  
    令F<sub>i</sub>=π<sub>R<sub>1</sub></sub>(F)，则(U<sup>k</sup><sub>i=1</sub>F<sub>i</sub>)<sup>+</sup>⊆F<sup>+</sup>  
	但是，(U<sup>k</sup><sub>i=1</sub>F<sub>i</sub>)<sup>+</sup>⊆F<sup>+</sup>并不一般成立
## 将关系模式分解成高级范式
## 在设计中使用规范化理论
